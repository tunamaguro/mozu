//! Code generated by sqlc. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-rust-postgres version: v0.1.3
#[derive(PartialEq, Debug, Clone, postgres_types::ToSql, postgres_types::FromSql)]
#[postgres(name = "actor_type")]
pub enum ActorType {
    #[postgres(name = "Person")]
    Person,
    #[postgres(name = "Application")]
    Application,
    #[postgres(name = "Service")]
    Service,
    #[postgres(name = "Group")]
    Group,
    #[postgres(name = "Organization")]
    Organization,
}
pub const CREATE_ACCOUNT: &str = r#"-- name: CreateAccount :exec
INSERT INTO accounts (id, name)
VALUES ($1, $2)"#;
pub async fn create_account(
    client: &impl deadpool_postgres::GenericClient,
    accounts_id: &uuid::Uuid,
    accounts_name: &str,
) -> Result<u64, deadpool_postgres::tokio_postgres::Error> {
    client
        .execute(CREATE_ACCOUNT, &[&accounts_id, &accounts_name])
        .await
}
pub const FIND_ACCOUNT_BY_ID: &str = r#"-- name: FindAccountById :one
SELECT
    id,
    name
FROM accounts
WHERE id = $1"#;
#[derive(PartialEq, Debug, Clone)]
pub struct FindAccountByIdRow {
    pub accounts_id: uuid::Uuid,
    pub accounts_name: String,
}
pub async fn find_account_by_id(
    client: &impl deadpool_postgres::GenericClient,
    accounts_id: &uuid::Uuid,
) -> Result<Option<FindAccountByIdRow>, deadpool_postgres::tokio_postgres::Error> {
    let row = client
        .query_opt(FIND_ACCOUNT_BY_ID, &[&accounts_id])
        .await?;
    let v = match row {
        Some(v) => FindAccountByIdRow {
            accounts_id: v.try_get(0)?,
            accounts_name: v.try_get(1)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const FIND_ACCOUNT_BY_NAME: &str = r#"-- name: FindAccountByName :one
SELECT
    id,
    name
FROM accounts
WHERE name = $1"#;
#[derive(PartialEq, Debug, Clone)]
pub struct FindAccountByNameRow {
    pub accounts_id: uuid::Uuid,
    pub accounts_name: String,
}
pub async fn find_account_by_name(
    client: &impl deadpool_postgres::GenericClient,
    accounts_name: &str,
) -> Result<Option<FindAccountByNameRow>, deadpool_postgres::tokio_postgres::Error> {
    let row = client
        .query_opt(FIND_ACCOUNT_BY_NAME, &[&accounts_name])
        .await?;
    let v = match row {
        Some(v) => FindAccountByNameRow {
            accounts_id: v.try_get(0)?,
            accounts_name: v.try_get(1)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const CREATE_ACTOR: &str = r#"-- name: CreateActor :exec
INSERT INTO actors (
    id,
    type,
    name,
    host,
    actor_url,
    inbox_url,
    outbox_url,
    shared_inbox_url,
    account_id
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
)"#;
pub async fn create_actor(
    client: &impl deadpool_postgres::GenericClient,
    actors_id: &uuid::Uuid,
    actors_type: &ActorType,
    actors_name: &str,
    actors_host: &str,
    actors_actor_url: &str,
    actors_inbox_url: &str,
    actors_outbox_url: &str,
    actors_shared_inbox_url: Option<&str>,
    actors_account_id: Option<&uuid::Uuid>,
) -> Result<u64, deadpool_postgres::tokio_postgres::Error> {
    client
        .execute(
            CREATE_ACTOR,
            &[
                &actors_id,
                &actors_type,
                &actors_name,
                &actors_host,
                &actors_actor_url,
                &actors_inbox_url,
                &actors_outbox_url,
                &actors_shared_inbox_url,
                &actors_account_id,
            ],
        )
        .await
}
pub const GET_ACTOR: &str = r#"-- name: GetActor :one
SELECT
    actors.id,
    actors.type,
    actors.name,
    actors.host,
    actors.actor_url,
    actors.inbox_url,
    actors.outbox_url,
    actors.shared_inbox_url,
    actors.account_id
FROM actors
WHERE actors.id = $1"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetActorRow {
    pub actors_id: uuid::Uuid,
    pub actors_type: ActorType,
    pub actors_name: String,
    pub actors_host: String,
    pub actors_actor_url: String,
    pub actors_inbox_url: String,
    pub actors_outbox_url: String,
    pub actors_shared_inbox_url: Option<String>,
    pub actors_account_id: Option<uuid::Uuid>,
}
pub async fn get_actor(
    client: &impl deadpool_postgres::GenericClient,
    actors_id: &uuid::Uuid,
) -> Result<Option<GetActorRow>, deadpool_postgres::tokio_postgres::Error> {
    let row = client.query_opt(GET_ACTOR, &[&actors_id]).await?;
    let v = match row {
        Some(v) => GetActorRow {
            actors_id: v.try_get(0)?,
            actors_type: v.try_get(1)?,
            actors_name: v.try_get(2)?,
            actors_host: v.try_get(3)?,
            actors_actor_url: v.try_get(4)?,
            actors_inbox_url: v.try_get(5)?,
            actors_outbox_url: v.try_get(6)?,
            actors_shared_inbox_url: v.try_get(7)?,
            actors_account_id: v.try_get(8)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const GET_ACTOR_BY_ACTOR_URL: &str = r#"-- name: GetActorByActorUrl :one
SELECT
    actors.id,
    actors.type,
    actors.name,
    actors.host,
    actors.actor_url,
    actors.inbox_url,
    actors.outbox_url,
    actors.shared_inbox_url,
    actors.account_id
FROM actors
WHERE actors.actor_url = $1"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetActorByActorUrlRow {
    pub actors_id: uuid::Uuid,
    pub actors_type: ActorType,
    pub actors_name: String,
    pub actors_host: String,
    pub actors_actor_url: String,
    pub actors_inbox_url: String,
    pub actors_outbox_url: String,
    pub actors_shared_inbox_url: Option<String>,
    pub actors_account_id: Option<uuid::Uuid>,
}
pub async fn get_actor_by_actor_url(
    client: &impl deadpool_postgres::GenericClient,
    actors_actor_url: &str,
) -> Result<Option<GetActorByActorUrlRow>, deadpool_postgres::tokio_postgres::Error> {
    let row = client
        .query_opt(GET_ACTOR_BY_ACTOR_URL, &[&actors_actor_url])
        .await?;
    let v = match row {
        Some(v) => GetActorByActorUrlRow {
            actors_id: v.try_get(0)?,
            actors_type: v.try_get(1)?,
            actors_name: v.try_get(2)?,
            actors_host: v.try_get(3)?,
            actors_actor_url: v.try_get(4)?,
            actors_inbox_url: v.try_get(5)?,
            actors_outbox_url: v.try_get(6)?,
            actors_shared_inbox_url: v.try_get(7)?,
            actors_account_id: v.try_get(8)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const GET_ACTOR_BY_NAME_AND_HOST: &str = r#"-- name: GetActorByNameAndHost :one
SELECT
    actors.id,
    actors.type,
    actors.name,
    actors.host,
    actors.actor_url,
    actors.inbox_url,
    actors.outbox_url,
    actors.shared_inbox_url,
    actors.account_id
FROM actors
WHERE actors.name = $1 AND actors.host = $2"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetActorByNameAndHostRow {
    pub actors_id: uuid::Uuid,
    pub actors_type: ActorType,
    pub actors_name: String,
    pub actors_host: String,
    pub actors_actor_url: String,
    pub actors_inbox_url: String,
    pub actors_outbox_url: String,
    pub actors_shared_inbox_url: Option<String>,
    pub actors_account_id: Option<uuid::Uuid>,
}
pub async fn get_actor_by_name_and_host(
    client: &impl deadpool_postgres::GenericClient,
    actors_name: &str,
    actors_host: &str,
) -> Result<Option<GetActorByNameAndHostRow>, deadpool_postgres::tokio_postgres::Error> {
    let row = client
        .query_opt(GET_ACTOR_BY_NAME_AND_HOST, &[&actors_name, &actors_host])
        .await?;
    let v = match row {
        Some(v) => GetActorByNameAndHostRow {
            actors_id: v.try_get(0)?,
            actors_type: v.try_get(1)?,
            actors_name: v.try_get(2)?,
            actors_host: v.try_get(3)?,
            actors_actor_url: v.try_get(4)?,
            actors_inbox_url: v.try_get(5)?,
            actors_outbox_url: v.try_get(6)?,
            actors_shared_inbox_url: v.try_get(7)?,
            actors_account_id: v.try_get(8)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const GET_ACTOR_BY_ACCOUNT_ID: &str = r#"-- name: GetActorByAccountId :one
SELECT
    actors.id,
    actors.type,
    actors.name,
    actors.host,
    actors.actor_url,
    actors.inbox_url,
    actors.outbox_url,
    actors.shared_inbox_url,
    actors.account_id
FROM actors
WHERE actors.account_id = $1"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetActorByAccountIdRow {
    pub actors_id: uuid::Uuid,
    pub actors_type: ActorType,
    pub actors_name: String,
    pub actors_host: String,
    pub actors_actor_url: String,
    pub actors_inbox_url: String,
    pub actors_outbox_url: String,
    pub actors_shared_inbox_url: Option<String>,
    pub actors_account_id: Option<uuid::Uuid>,
}
pub async fn get_actor_by_account_id(
    client: &impl deadpool_postgres::GenericClient,
    actors_account_id: Option<&uuid::Uuid>,
) -> Result<Option<GetActorByAccountIdRow>, deadpool_postgres::tokio_postgres::Error> {
    let row = client
        .query_opt(GET_ACTOR_BY_ACCOUNT_ID, &[&actors_account_id])
        .await?;
    let v = match row {
        Some(v) => GetActorByAccountIdRow {
            actors_id: v.try_get(0)?,
            actors_type: v.try_get(1)?,
            actors_name: v.try_get(2)?,
            actors_host: v.try_get(3)?,
            actors_actor_url: v.try_get(4)?,
            actors_inbox_url: v.try_get(5)?,
            actors_outbox_url: v.try_get(6)?,
            actors_shared_inbox_url: v.try_get(7)?,
            actors_account_id: v.try_get(8)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
